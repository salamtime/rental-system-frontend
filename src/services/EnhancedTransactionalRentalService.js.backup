/**
 * Enhanced Transactional Rental Service with CRITICAL CUSTOMER LINK ENFORCEMENT
 * AND PAYMENT STATUS TRACKING
 * 
 * CRITICAL FIX: Guarantees customer_id is properly saved during rental creation
 * NEW FEATURE: Payment Status tracking for financial management
 */

import { supabase } from '../lib/supabase';

class EnhancedTransactionalRentalService {
  constructor() {
    this.tableName = 'app_4c3a7a6153_rentals';
    this.vehiclesTableName = 'app_4c3a7a6153_vehicles';
    this.customersTableName = 'app_4c3a7a6153_customers';
  }

  /**
   * CRITICAL FIX: Enhanced UUID validation
   */
  validateRentalId(rentalId) {
    if (!rentalId) return false;
    
    // Check if it's a valid UUID format
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    const isValid = uuidRegex.test(rentalId);
    
    if (!isValid) {
      console.error('‚ùå INVALID RENTAL ID FORMAT:', rentalId);
    }
    
    return isValid;
  }

  /**
   * CRITICAL FIX: Validate customer ID format
   */
  validateCustomerId(customerId) {
    if (!customerId) return false;
    
    // Check if it's a valid customer ID format (cust_...)
    const isValidFormat = customerId.startsWith('cust_');
    
    if (!isValidFormat) {
      console.error('‚ùå INVALID CUSTOMER ID FORMAT:', customerId);
    }
    
    return isValidFormat;
  }

  /**
   * NEW: Validate payment status
   */
  validatePaymentStatus(paymentStatus) {
    const validStatuses = ['Pending', 'Paid in Full', 'Partially Paid', 'Refunded'];
    
    if (!paymentStatus) {
      return 'Pending'; // Default value
    }
    
    if (!validStatuses.includes(paymentStatus)) {
      console.warn('‚ö†Ô∏è INVALID PAYMENT STATUS:', paymentStatus, '- defaulting to Pending');
      return 'Pending';
    }
    
    return paymentStatus;
  }

  /**
   * CRITICAL FIX: Enhanced rental data sanitization with customer ID and payment status enforcement
   */
  sanitizeRentalData(rentalData) {
    console.log('üîç SANITIZING RENTAL DATA with customer ID and payment status enforcement...');
    console.log('üì¶ Raw rental data:', JSON.stringify(rentalData, null, 2));

    const sanitized = { ...rentalData };

    // CRITICAL CUSTOMER ID ENFORCEMENT
    if (rentalData.customer_id) {
      if (this.validateCustomerId(rentalData.customer_id)) {
        sanitized.customer_id = rentalData.customer_id;
        console.log('‚úÖ CUSTOMER ID VALIDATED:', sanitized.customer_id);
      } else {
        console.error('‚ùå CRITICAL ERROR: Invalid customer ID format:', rentalData.customer_id);
        throw new Error(`Invalid customer ID format: ${rentalData.customer_id}. Must start with 'cust_'`);
      }
    } else {
      console.error('‚ùå CRITICAL ERROR: No customer ID provided in rental data');
      throw new Error('Customer ID is required for rental creation');
    }

    // NEW: Payment Status Validation and Enforcement
    sanitized.payment_status = this.validatePaymentStatus(rentalData.payment_status);
    console.log('‚úÖ PAYMENT STATUS VALIDATED:', sanitized.payment_status);

    // Validate rental ID if provided (for updates)
    if (sanitized.id && !this.validateRentalId(sanitized.id)) {
      console.error('‚ùå INVALID RENTAL ID - removing from sanitized data');
      delete sanitized.id;
    }

    // Validate excludeRentalId if provided
    if (sanitized.excludeRentalId && !this.validateRentalId(sanitized.excludeRentalId)) {
      console.error('‚ùå INVALID EXCLUDE RENTAL ID - removing from sanitized data');
      delete sanitized.excludeRentalId;
    }

    // Remove any datetime values that might be mistaken for UUIDs
    Object.keys(sanitized).forEach(key => {
      const value = sanitized[key];
      if (typeof value === 'string' && value.includes('T') && value.includes('Z')) {
        // This looks like a datetime, don't use it as a UUID
        if (key.includes('id') && key !== 'customer_id') {
          console.log(`‚ö†Ô∏è REMOVING DATETIME VALUE from ${key}:`, value);
          delete sanitized[key];
        }
      }
    });

    console.log('‚úÖ SANITIZED RENTAL DATA:', JSON.stringify(sanitized, null, 2));
    return sanitized;
  }

  /**
   * CRITICAL FIX: Enhanced vehicle availability check with proper UUID validation
   */
  async checkVehicleAvailability(vehicleId, startDate, endDate, excludeRentalId = null) {
    console.log('üîç CHECKING VEHICLE AVAILABILITY with enhanced validation...');
    console.log('üìä Parameters:', { vehicleId, startDate, endDate, excludeRentalId });

    try {
      // Validate excludeRentalId if provided
      if (excludeRentalId && !this.validateRentalId(excludeRentalId)) {
        console.error('‚ùå INVALID EXCLUDE RENTAL ID - proceeding without exclusion');
        excludeRentalId = null;
      }

      let query = supabase
        .from(this.tableName)
        .select('id, start_date, end_date, rental_status')
        .eq('vehicle_id', vehicleId)
        .in('rental_status', ['active', 'confirmed', 'pending']);

      // Add date range overlap condition
      query = query.or(`and(start_date.lte.${endDate},end_date.gte.${startDate})`);

      // Exclude specific rental if provided and valid
      if (excludeRentalId) {
        console.log('üîç EXCLUDING RENTAL ID:', excludeRentalId);
        query = query.neq('id', excludeRentalId);
      }

      const { data: conflictingRentals, error } = await query;

      if (error) {
        console.error('‚ùå AVAILABILITY CHECK ERROR:', error);
        throw new Error(`Availability check failed: ${error.message}`);
      }

      const isAvailable = !conflictingRentals || conflictingRentals.length === 0;
      
      console.log('üìä AVAILABILITY RESULT:', {
        isAvailable,
        conflictingRentals: conflictingRentals?.length || 0
      });

      return {
        available: isAvailable,
        conflictingRentals: conflictingRentals || []
      };

    } catch (error) {
      console.error('‚ùå AVAILABILITY CHECK FAILED:', error);
      throw error;
    }
  }

  /**
   * CRITICAL FIX: Enhanced rental creation with GUARANTEED customer ID and payment status enforcement
   */
  async createRental(rentalData) {
    console.log('üÜï CREATING RENTAL with GUARANTEED customer ID and payment status enforcement...');
    console.log('üì¶ Input rental data:', JSON.stringify(rentalData, null, 2));

    try {
      // CRITICAL: Sanitize and validate rental data (includes customer ID and payment status validation)
      const sanitizedData = this.sanitizeRentalData(rentalData);
      
      // CRITICAL CUSTOMER ID ENFORCEMENT - Double check
      if (!sanitizedData.customer_id || !this.validateCustomerId(sanitizedData.customer_id)) {
        throw new Error('CRITICAL ERROR: Valid customer ID is required for rental creation');
      }

      // Verify customer exists before creating rental
      console.log('üîç VERIFYING CUSTOMER EXISTS:', sanitizedData.customer_id);
      const { data: existingCustomer, error: customerError } = await supabase
        .from(this.customersTableName)
        .select('id')
        .eq('id', sanitizedData.customer_id)
        .single();

      if (customerError || !existingCustomer) {
        console.error('‚ùå CUSTOMER VERIFICATION FAILED:', customerError);
        throw new Error(`Customer ${sanitizedData.customer_id} does not exist. Cannot create rental.`);
      }

      console.log('‚úÖ CUSTOMER VERIFIED:', existingCustomer.id);

      // Check vehicle availability
      const availability = await this.checkVehicleAvailability(
        sanitizedData.vehicle_id,
        sanitizedData.start_date,
        sanitizedData.end_date
      );

      if (!availability.available) {
        throw new Error('Vehicle is not available for the selected dates');
      }

      // CRITICAL: Prepare rental payload with GUARANTEED customer ID and payment status
      const rentalPayload = {
        ...sanitizedData,
        customer_id: sanitizedData.customer_id, // EXPLICIT ENFORCEMENT
        payment_status: sanitizedData.payment_status || 'Pending', // EXPLICIT PAYMENT STATUS
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      // CRITICAL VALIDATION: Final check before database write
      if (!rentalPayload.customer_id || !rentalPayload.customer_id.startsWith('cust_')) {
        console.error('‚ùå CRITICAL ERROR: Customer ID missing or invalid in final payload');
        console.error('üì¶ Final payload:', JSON.stringify(rentalPayload, null, 2));
        throw new Error('CRITICAL ERROR: Customer ID link is missing from rental payload!');
      }

      console.log('‚úÖ FINAL RENTAL PAYLOAD with GUARANTEED customer ID and payment status:');
      console.log('üì¶ Payload:', JSON.stringify(rentalPayload, null, 2));
      console.log('üéØ CUSTOMER ID BEING SAVED:', rentalPayload.customer_id);
      console.log('üí∞ PAYMENT STATUS BEING SAVED:', rentalPayload.payment_status);

      // Execute database insert with guaranteed customer ID and payment status
      const { data: newRental, error: insertError } = await supabase
        .from(this.tableName)
        .insert([rentalPayload])
        .select()
        .single();

      if (insertError) {
        console.error('‚ùå RENTAL CREATION ERROR:', insertError);
        throw new Error(`Failed to create rental: ${insertError.message}`);
      }

      // CRITICAL VERIFICATION: Confirm customer ID and payment status were saved
      if (!newRental.customer_id) {
        console.error('‚ùå CRITICAL ERROR: Customer ID was not saved to rental record!');
        console.error('üì¶ Created rental:', JSON.stringify(newRental, null, 2));
        throw new Error('CRITICAL ERROR: Customer ID was not saved to rental record!');
      }

      console.log('‚úÖ RENTAL CREATED SUCCESSFULLY with customer ID link and payment status:');
      console.log('üìä Created rental:', JSON.stringify(newRental, null, 2));
      console.log('üéØ CONFIRMED CUSTOMER ID SAVED:', newRental.customer_id);
      console.log('üí∞ CONFIRMED PAYMENT STATUS SAVED:', newRental.payment_status);

      return {
        success: true,
        data: newRental,
        message: 'Rental created successfully with guaranteed customer link and payment status'
      };

    } catch (error) {
      console.error('‚ùå RENTAL CREATION FAILED:', error);
      return {
        success: false,
        error: error.message,
        message: 'Failed to create rental'
      };
    }
  }

  /**
   * CRITICAL FIX: Enhanced rental update with customer ID and payment status preservation
   */
  async updateRental(rentalId, updateData) {
    console.log('üîÑ UPDATING RENTAL with customer ID and payment status preservation...');
    console.log('üìä Parameters:', { rentalId, updateData });

    try {
      // Validate rental ID
      if (!this.validateRentalId(rentalId)) {
        throw new Error(`Invalid rental ID format: ${rentalId}`);
      }

      // Get existing rental to preserve customer ID and payment status
      const { data: existingRental, error: fetchError } = await supabase
        .from(this.tableName)
        .select('*')
        .eq('id', rentalId)
        .single();

      if (fetchError || !existingRental) {
        throw new Error(`Rental not found: ${rentalId}`);
      }

      console.log('üìä EXISTING RENTAL:', JSON.stringify(existingRental, null, 2));

      // CRITICAL: Preserve existing customer ID if not provided in update
      let finalUpdateData = { ...updateData };
      
      if (!finalUpdateData.customer_id && existingRental.customer_id) {
        finalUpdateData.customer_id = existingRental.customer_id;
        console.log('‚úÖ PRESERVING EXISTING CUSTOMER ID:', existingRental.customer_id);
      }

      // NEW: Validate and preserve payment status
      if (finalUpdateData.payment_status) {
        finalUpdateData.payment_status = this.validatePaymentStatus(finalUpdateData.payment_status);
        console.log('‚úÖ PAYMENT STATUS UPDATED:', finalUpdateData.payment_status);
      } else if (existingRental.payment_status) {
        finalUpdateData.payment_status = existingRental.payment_status;
        console.log('‚úÖ PRESERVING EXISTING PAYMENT STATUS:', existingRental.payment_status);
      }

      // If customer_id is provided in update, validate it
      if (finalUpdateData.customer_id && !this.validateCustomerId(finalUpdateData.customer_id)) {
        throw new Error(`Invalid customer ID format in update: ${finalUpdateData.customer_id}`);
      }

      // Sanitize update data
      const sanitizedUpdateData = this.sanitizeRentalData(finalUpdateData);

      // Check vehicle availability if dates or vehicle changed
      if (sanitizedUpdateData.vehicle_id || sanitizedUpdateData.start_date || sanitizedUpdateData.end_date) {
        const vehicleId = sanitizedUpdateData.vehicle_id || existingRental.vehicle_id;
        const startDate = sanitizedUpdateData.start_date || existingRental.start_date;
        const endDate = sanitizedUpdateData.end_date || existingRental.end_date;

        const availability = await this.checkVehicleAvailability(
          vehicleId,
          startDate,
          endDate,
          rentalId // Exclude current rental from availability check
        );

        if (!availability.available) {
          throw new Error('Vehicle is not available for the updated dates');
        }
      }

      // CRITICAL: Ensure customer ID and payment status are in final update payload
      const updatePayload = {
        ...sanitizedUpdateData,
        updated_at: new Date().toISOString()
      };

      // CRITICAL VALIDATION: Ensure customer ID is preserved
      if (!updatePayload.customer_id) {
        console.error('‚ùå CRITICAL ERROR: Customer ID missing in update payload');
        throw new Error('CRITICAL ERROR: Customer ID must be preserved in rental update');
      }

      console.log('‚úÖ UPDATE PAYLOAD with customer ID and payment status:');
      console.log('üì¶ Payload:', JSON.stringify(updatePayload, null, 2));
      console.log('üéØ CUSTOMER ID BEING SAVED:', updatePayload.customer_id);
      console.log('üí∞ PAYMENT STATUS BEING SAVED:', updatePayload.payment_status);

      // Execute database update
      const { data: updatedRental, error: updateError } = await supabase
        .from(this.tableName)
        .update(updatePayload)
        .eq('id', rentalId)
        .select()
        .single();

      if (updateError) {
        console.error('‚ùå RENTAL UPDATE ERROR:', updateError);
        throw new Error(`Failed to update rental: ${updateError.message}`);
      }

      // CRITICAL VERIFICATION: Confirm customer ID is still present
      if (!updatedRental.customer_id) {
        console.error('‚ùå CRITICAL ERROR: Customer ID was lost during update!');
        console.error('üì¶ Updated rental:', JSON.stringify(updatedRental, null, 2));
        throw new Error('CRITICAL ERROR: Customer ID was lost during rental update!');
      }

      console.log('‚úÖ RENTAL UPDATED SUCCESSFULLY with customer ID and payment status preserved:');
      console.log('üìä Updated rental:', JSON.stringify(updatedRental, null, 2));
      console.log('üéØ CONFIRMED CUSTOMER ID PRESERVED:', updatedRental.customer_id);
      console.log('üí∞ CONFIRMED PAYMENT STATUS PRESERVED:', updatedRental.payment_status);

      return {
        success: true,
        data: updatedRental,
        message: 'Rental updated successfully with customer ID and payment status preserved'
      };

    } catch (error) {
      console.error('‚ùå RENTAL UPDATE FAILED:', error);
      return {
        success: false,
        error: error.message,
        message: 'Failed to update rental'
      };
    }
  }

  /**
   * CRITICAL FIX: Get rental with customer information
   */
  async getRentalWithCustomer(rentalId) {
    console.log('üîç GETTING RENTAL WITH CUSTOMER INFO:', rentalId);

    try {
      if (!this.validateRentalId(rentalId)) {
        throw new Error(`Invalid rental ID format: ${rentalId}`);
      }

      const { data: rental, error } = await supabase
        .from(this.tableName)
        .select(`
          *,
          customer:${this.customersTableName}(*)
        `)
        .eq('id', rentalId)
        .single();

      if (error) {
        console.error('‚ùå RENTAL FETCH ERROR:', error);
        throw new Error(`Failed to fetch rental: ${error.message}`);
      }

      console.log('‚úÖ RENTAL WITH CUSTOMER FETCHED:');
      console.log('üìä Rental:', JSON.stringify(rental, null, 2));
      console.log('üéØ CUSTOMER ID IN RENTAL:', rental.customer_id);
      console.log('üí∞ PAYMENT STATUS:', rental.payment_status);
      console.log('üë§ CUSTOMER DATA:', rental.customer);

      return {
        success: true,
        data: rental,
        message: 'Rental with customer information fetched successfully'
      };

    } catch (error) {
      console.error('‚ùå RENTAL WITH CUSTOMER FETCH FAILED:', error);
      return {
        success: false,
        error: error.message,
        message: 'Failed to fetch rental with customer information'
      };
    }
  }

  /**
   * CRITICAL FIX: Verify rental-customer links
   */
  async verifyRentalCustomerLinks() {
    console.log('üîç VERIFYING RENTAL-CUSTOMER LINKS...');

    try {
      const { data: rentals, error } = await supabase
        .from(this.tableName)
        .select('id, customer_id, payment_status')
        .limit(10);

      if (error) {
        throw new Error(`Failed to fetch rentals: ${error.message}`);
      }

      const verification = {
        total: rentals.length,
        withCustomerId: 0,
        withoutCustomerId: 0,
        validCustomerIds: 0,
        invalidCustomerIds: 0,
        paymentStatusDistribution: {},
        details: []
      };

      for (const rental of rentals) {
        const detail = {
          rentalId: rental.id,
          customerId: rental.customer_id,
          paymentStatus: rental.payment_status,
          hasCustomerId: !!rental.customer_id,
          isValidFormat: false
        };

        if (rental.customer_id) {
          verification.withCustomerId++;
          detail.isValidFormat = this.validateCustomerId(rental.customer_id);
          
          if (detail.isValidFormat) {
            verification.validCustomerIds++;
          } else {
            verification.invalidCustomerIds++;
          }
        } else {
          verification.withoutCustomerId++;
        }

        // Track payment status distribution
        const status = rental.payment_status || 'Unknown';
        verification.paymentStatusDistribution[status] = 
          (verification.paymentStatusDistribution[status] || 0) + 1;

        verification.details.push(detail);
      }

      console.log('üìä RENTAL-CUSTOMER LINK VERIFICATION:');
      console.log(JSON.stringify(verification, null, 2));

      return {
        success: true,
        data: verification,
        message: 'Rental-customer link verification completed'
      };

    } catch (error) {
      console.error('‚ùå RENTAL-CUSTOMER LINK VERIFICATION FAILED:', error);
      return {
        success: false,
        error: error.message,
        message: 'Failed to verify rental-customer links'
      };
    }
  }
}

// Export singleton instance
export const enhancedTransactionalRentalService = new EnhancedTransactionalRentalService();
export default enhancedTransactionalRentalService;