import { supabase } from '../lib/supabase.js';
import { optimizedGeminiVisionOCR } from './ocr/optimizedGeminiVisionOcr.js';

/**
 * EnhancedUnifiedCustomerService - Complete customer management with ID scanning integration
 * 
 * FEATURES:
 * - OCR-based customer data extraction from ID scans
 * - Automatic customer creation/update with image storage
 * - Enhanced data validation and sanitization
 * - Comprehensive error handling and logging
 * - FINAL FIX: Guaranteed id_scan_url field assignment during customer creation
 * - CRITICAL FIX: Phone number mapping from rental form to customer record
 * - RESTORED: processSequentialImageUpload function for ID scanning workflow
 * - FORM AUTO-POPULATION FIX: Returns extractedData in correct format for form population
 * - MOROCCAN DRIVING LICENSE FIX: Correct mapping of document_number to licence_number
 */
class EnhancedUnifiedCustomerService {

  /**
   * MOROCCAN DRIVING LICENSE FIX: Enhanced OCR data mapping with document-specific logic
   * Correctly maps Moroccan driving license document_number to licence_number field
   */
  static enhancedOcrDataMapping(ocrResult) {
    console.log('üá≤üá¶ MOROCCAN LICENSE FIX: Starting enhanced OCR data mapping...');
    console.log('üìã OCR Result:', JSON.stringify(ocrResult, null, 2));
    
    // Extract document type and country information
    const documentType = (ocrResult.document_type || '').toLowerCase();
    const country = (ocrResult.country || '').toLowerCase();
    const isDriverLicense = documentType.includes('driving') || documentType.includes('license') || documentType.includes('licence');
    const isMoroccan = country.includes('morocco') || country.includes('moroccan');
    
    console.log('üîç MOROCCAN LICENSE FIX: Document analysis:');
    console.log('  - Document Type:', documentType);
    console.log('  - Country:', country);
    console.log('  - Is Driver License:', isDriverLicense);
    console.log('  - Is Moroccan:', isMoroccan);
    
    // CRITICAL CONDITION CHECK: Moroccan Driving License
    if (isMoroccan && isDriverLicense) {
      console.log('‚úÖ MOROCCAN LICENSE FIX: Detected Moroccan Driving License - applying specific mapping...');
      
      // MAPPING FIX 1: Assign License Number from document_number
      const licenceNumber = ocrResult.document_number || ocrResult.licence_number || '';
      
      // MAPPING FIX 2: Clear Generic ID (ensure license number doesn't populate id_number)
      const idNumber = null; // Explicitly set to null for driving licenses
      
      // MAPPING FIX 3: Fix Date Mapping - Correct issue vs expiry date confusion
      let licenceIssueDate = ocrResult.issue_date || null;
      let licenceExpiryDate = ocrResult.expiry_date || null;
      
      // Special handling: If expiry_date looks like an issue date, correct it
      if (licenceExpiryDate && licenceIssueDate && licenceExpiryDate === licenceIssueDate) {
        console.log('‚ö†Ô∏è MOROCCAN LICENSE FIX: Detected issue/expiry date confusion - correcting...');
        licenceExpiryDate = null; // Clear incorrect expiry date
      }
      
      const mappedData = {
        // Basic information
        full_name: ocrResult.full_name || '',
        date_of_birth: ocrResult.date_of_birth || '',
        nationality: ocrResult.nationality || 'Moroccan',
        gender: ocrResult.gender || null,
        
        // CRITICAL FIXES for Moroccan Driving License
        licence_number: licenceNumber, // FIX 1: Map document_number to licence_number
        id_number: idNumber, // FIX 2: Clear generic ID field
        licence_issue_date: licenceIssueDate, // FIX 3: Correct issue date
        licence_expiry_date: licenceExpiryDate, // FIX 3: Correct expiry date (or null)
        
        // Additional fields
        place_of_birth: ocrResult.place_of_birth || null,
        confidence_estimate: ocrResult.confidence_estimate || 0.8
      };
      
      console.log('üéØ MOROCCAN LICENSE FIX: Applied specific mapping:');
      console.log('  - licence_number:', mappedData.licence_number, '(from document_number)');
      console.log('  - id_number:', mappedData.id_number, '(cleared for driving license)');
      console.log('  - licence_issue_date:', mappedData.licence_issue_date);
      console.log('  - licence_expiry_date:', mappedData.licence_expiry_date);
      
      return mappedData;
      
    } else {
      console.log('üìÑ MOROCCAN LICENSE FIX: Not a Moroccan driving license - using default mapping...');
      
      // Default mapping for other documents (ID cards, passports, etc.)
      return {
        full_name: ocrResult.full_name || '',
        date_of_birth: ocrResult.date_of_birth || '',
        nationality: ocrResult.nationality || null,
        gender: ocrResult.gender || null,
        id_number: ocrResult.document_number || ocrResult.id_number || null, // Use document_number for ID cards
        licence_number: ocrResult.licence_number || null, // Only if explicitly provided
        licence_issue_date: ocrResult.licence_issue_date || ocrResult.issue_date || null,
        licence_expiry_date: ocrResult.licence_expiry_date || ocrResult.expiry_date || null,
        place_of_birth: ocrResult.place_of_birth || null,
        confidence_estimate: ocrResult.confidence_estimate || 0.8
      };
    }
  }

  /**
   * FINAL FIX: Save customer with GUARANTEED id_scan_url field assignment + PHONE NUMBER MAPPING
   * This is the critical function that ensures the uploaded ID scan URL and phone number are properly saved
   */
  static async saveCustomer(customerData, scanResult = null) {
    console.log('üÜï FINAL FIX: Starting customer save with GUARANTEED id_scan_url assignment + phone mapping:', {
      customerData,
      scanResult
    });
    
    try {
      // STEP 1: Validate input data
      if (!customerData) {
        throw new Error('Customer data is required');
      }

      // STEP 2: FINAL CRITICAL FIX - Extract and validate id_scan_url
      let idScanUrl = null;
      
      // Priority 1: Use scanResult.file_public_url if provided
      if (scanResult?.file_public_url) {
        idScanUrl = scanResult.file_public_url;
        console.log('‚úÖ FINAL FIX: Using scanResult.file_public_url for id_scan_url:', idScanUrl);
      }
      // Priority 2: Use customerData.id_scan_url if provided
      else if (customerData.id_scan_url) {
        idScanUrl = customerData.id_scan_url;
        console.log('‚úÖ FINAL FIX: Using customerData.id_scan_url:', idScanUrl);
      }
      // Priority 3: Check for other URL fields
      else if (customerData.scanUrl) {
        idScanUrl = customerData.scanUrl;
        console.log('‚úÖ FINAL FIX: Using customerData.scanUrl:', idScanUrl);
      }
      else {
        console.log('‚ö†Ô∏è FINAL FIX: No id_scan_url provided, will be set to null');
      }

      // STEP 3: CRITICAL PHONE NUMBER MAPPING FIX
      let phoneNumber = null;
      
      // Priority 1: Use customer_phone from rental form
      if (customerData.customer_phone) {
        phoneNumber = customerData.customer_phone;
        console.log('‚úÖ PHONE MAPPING FIX: Using customer_phone from rental form:', phoneNumber);
      }
      // Priority 2: Use phone field directly
      else if (customerData.phone) {
        phoneNumber = customerData.phone;
        console.log('‚úÖ PHONE MAPPING FIX: Using phone field:', phoneNumber);
      }
      else {
        console.log('‚ö†Ô∏è PHONE MAPPING FIX: No phone number provided');
      }

      // STEP 4: Sanitize and validate customer data
      const sanitizedCustomerData = this.sanitizeCustomerData(customerData);
      console.log('üßπ FINAL FIX: Sanitized customer data:', sanitizedCustomerData);

      // STEP 5: CRITICAL IMAGE URL + PHONE ASSIGNMENT - Build final customer data with GUARANTEED fields
      const finalCustomerData = {
        // All OCR extracted data and form data
        full_name: sanitizedCustomerData.full_name || sanitizedCustomerData.customer_name,
        email: sanitizedCustomerData.email || sanitizedCustomerData.customer_email || null,
        phone: phoneNumber, // CRITICAL PHONE MAPPING FIX
        date_of_birth: sanitizedCustomerData.date_of_birth || sanitizedCustomerData.customer_dob || null,
        nationality: sanitizedCustomerData.nationality || sanitizedCustomerData.customer_nationality || null,
        licence_number: sanitizedCustomerData.licence_number || sanitizedCustomerData.customer_licence_number || null,
        id_number: sanitizedCustomerData.id_number || sanitizedCustomerData.customer_id_number || null,
        place_of_birth: sanitizedCustomerData.place_of_birth || sanitizedCustomerData.customer_place_of_birth || null,
        issue_date: sanitizedCustomerData.issue_date || sanitizedCustomerData.customer_issue_date || null,
        
        // FINAL CRITICAL FIX: GUARANTEE id_scan_url is assigned
        id_scan_url: idScanUrl, // THIS IS THE CRITICAL FIELD THAT WAS MISSING
        
        // Metadata
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      console.log('üéØ FINAL FIX: Final customer data with GUARANTEED id_scan_url + phone mapping:', finalCustomerData);
      console.log('üñºÔ∏è FINAL FIX: id_scan_url field value:', finalCustomerData.id_scan_url);
      console.log('üìû PHONE MAPPING FIX: phone field value:', finalCustomerData.phone);

      // STEP 6: Validate required fields
      if (!finalCustomerData.full_name) {
        throw new Error('Customer full name is required');
      }

      // STEP 7: FINAL VALIDATION - Ensure id_scan_url is properly set if image was uploaded
      if (scanResult && !finalCustomerData.id_scan_url) {
        console.error('‚ùå FINAL FIX: CRITICAL ERROR - scanResult provided but id_scan_url is null!');
        console.error('‚ùå FINAL FIX: scanResult:', scanResult);
        throw new Error('CRITICAL IMAGE URL ASSIGNMENT FAILURE: Scan result provided but id_scan_url could not be determined!');
      }

      // STEP 8: Check if customer already exists (for updates)
      let existingCustomer = null;
      if (finalCustomerData.licence_number) {
        const { data: licenceMatch } = await supabase
          .from('app_4c3a7a6153_customers')
          .select('*')
          .eq('licence_number', finalCustomerData.licence_number)
          .single();
        existingCustomer = licenceMatch;
      }

      if (!existingCustomer && finalCustomerData.id_number) {
        const { data: idMatch } = await supabase
          .from('app_4c3a7a6153_customers')
          .select('*')
          .eq('id_number', finalCustomerData.id_number)
          .single();
        existingCustomer = idMatch;
      }

      // STEP 9: Insert or update customer record with GUARANTEED id_scan_url + phone
      let customerResult;
      
      if (existingCustomer) {
        console.log('üîÑ FINAL FIX: Updating existing customer with id_scan_url + phone:', existingCustomer.id);
        
        // Update existing customer
        const { data: updatedCustomer, error: updateError } = await supabase
          .from('app_4c3a7a6153_customers')
          .update({
            ...finalCustomerData,
            updated_at: new Date().toISOString()
          })
          .eq('id', existingCustomer.id)
          .select()
          .single();

        if (updateError) {
          console.error('‚ùå FINAL FIX: Customer update failed:', updateError);
          throw new Error(`Customer update failed: ${updateError.message}`);
        }

        customerResult = updatedCustomer;
        console.log('‚úÖ FINAL FIX: Customer updated successfully with id_scan_url + phone:', customerResult.id);
      } else {
        console.log('üÜï FINAL FIX: Creating new customer with id_scan_url + phone...');
        
        // Create new customer
        const { data: newCustomer, error: createError } = await supabase
          .from('app_4c3a7a6153_customers')
          .insert([finalCustomerData])
          .select()
          .single();

        if (createError) {
          console.error('‚ùå FINAL FIX: Customer creation failed:', createError);
          throw new Error(`Customer creation failed: ${createError.message}`);
        }

        customerResult = newCustomer;
        console.log('‚úÖ FINAL FIX: Customer created successfully with id_scan_url + phone:', customerResult.id);
      }

      // STEP 10: FINAL VERIFICATION - Confirm id_scan_url and phone were saved to database
      if (idScanUrl && !customerResult.id_scan_url) {
        console.error('‚ùå FINAL FIX: CRITICAL ERROR - id_scan_url was not saved to database!');
        console.error('‚ùå FINAL FIX: Expected:', idScanUrl);
        console.error('‚ùå FINAL FIX: Actual:', customerResult.id_scan_url);
        throw new Error('FINAL CRITICAL ERROR: id_scan_url was not saved to customer record in database!');
      }

      if (phoneNumber && !customerResult.phone) {
        console.error('‚ùå PHONE MAPPING FIX: CRITICAL ERROR - phone was not saved to database!');
        console.error('‚ùå PHONE MAPPING FIX: Expected:', phoneNumber);
        console.error('‚ùå PHONE MAPPING FIX: Actual:', customerResult.phone);
        throw new Error('PHONE MAPPING CRITICAL ERROR: Phone number was not saved to customer record in database!');
      }

      console.log('‚úÖ FINAL FIX: Customer save completed successfully with GUARANTEED id_scan_url + phone mapping');
      console.log('üéØ FINAL FIX: Customer ID:', customerResult.id);
      console.log('üñºÔ∏è FINAL FIX: Confirmed id_scan_url saved:', customerResult.id_scan_url);
      console.log('üìû PHONE MAPPING FIX: Confirmed phone saved:', customerResult.phone);

      return {
        success: true,
        data: customerResult,
        message: 'Customer saved successfully with guaranteed id_scan_url assignment and phone mapping'
      };

    } catch (error) {
      console.error('‚ùå FINAL FIX: Customer save failed:', error);
      
      return {
        success: false,
        error: error.message,
        details: error
      };
    }
  }

  /**
   * FORM AUTO-POPULATION FIX + MOROCCAN LICENSE FIX: Process Sequential Image Upload with Complete ID Scanning Workflow
   * This function now returns extractedData in the correct format for form auto-population
   * AND correctly handles Moroccan driving license mapping
   */
  static async processSequentialImageUpload(imageFile, customerId, rentalId = null, scanType = 'document') {
    try {
      console.log('üîÑ FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Processing sequential image upload for customer:', customerId);
      console.log('üìÅ Image file:', imageFile?.name);
      console.log('üÜî Rental ID:', rentalId);
      console.log('üìã Scan type:', scanType);
      
      // Step 1: Validate inputs
      if (!imageFile) {
        throw new Error('Image file is required');
      }
      
      if (!customerId) {
        throw new Error('Customer ID is required');
      }
      
      // Step 2: Generate unique file path with timestamp
      const timestamp = Date.now();
      const fileExtension = imageFile.name.split('.').pop() || 'jpg';
      const fileName = `idscan_${timestamp}.${fileExtension}`;
      const filePath = `${customerId}/${fileName}`;

      console.log('üì§ FORM AUTO-POPULATION: Uploading image to storage bucket...');
      console.log('üìÅ File path:', filePath);

      // Step 3: Upload image to storage
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('id_scans')
        .upload(filePath, imageFile, {
          cacheControl: '3600',
          upsert: false
        });

      if (uploadError) {
        console.error('‚ùå FORM AUTO-POPULATION: Image upload failed:', uploadError);
        throw new Error(`Failed to upload image: ${uploadError.message}`);
      }

      console.log('‚úÖ FORM AUTO-POPULATION: Image uploaded successfully:', uploadData.path);

      // Step 4: Get public URL
      const { data: { publicUrl } } = supabase.storage
        .from('id_scans')
        .getPublicUrl(filePath);

      console.log('üñºÔ∏è FORM AUTO-POPULATION: Generated public URL:', publicUrl);

      // Step 5: Process image with ACTUAL OCR (not simulation)
      console.log('üîç FORM AUTO-POPULATION: Starting ACTUAL OCR processing...');
      
      let ocrResult;
      try {
        ocrResult = await optimizedGeminiVisionOCR.processIdDocument(imageFile, customerId);
        console.log('‚úÖ FORM AUTO-POPULATION: OCR processing completed:', ocrResult.success);
        console.log('üì¶ FORM AUTO-POPULATION: OCR extracted data:', JSON.stringify(ocrResult.data, null, 2));
      } catch (ocrError) {
        console.error('‚ùå FORM AUTO-POPULATION: OCR processing failed:', ocrError);
        ocrResult = {
          success: false,
          error: ocrError.message,
          data: {}
        };
      }

      // Step 6: Save customer data with id_scan_url and phone mapping
      let shouldPopulateForm = false;
      let responseMessage = '';
      let customerSaveResult = null;
      let extractedData = {}; // CRITICAL: This is what the form expects for auto-population

      if (ocrResult.success && ocrResult.data) {
        console.log('üîç FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Processing OCR data for customer save...');
        console.log('üì¶ FORM AUTO-POPULATION: OCR extracted data:', JSON.stringify(ocrResult.data, null, 2));
        
        // MOROCCAN LICENSE FIX: Apply enhanced OCR data mapping
        const enhancedMappedData = this.enhancedOcrDataMapping(ocrResult.data);
        console.log('üá≤üá¶ MOROCCAN LICENSE FIX: Enhanced mapped data:', JSON.stringify(enhancedMappedData, null, 2));
        
        // CRITICAL FIX: Map enhanced OCR data to form field names for auto-population
        extractedData = {
          customer_name: enhancedMappedData.full_name || '',
          customer_phone: enhancedMappedData.phone || '',
          customer_email: enhancedMappedData.email || '',
          customer_dob: enhancedMappedData.date_of_birth || '',
          customer_nationality: enhancedMappedData.nationality || '',
          customer_licence_number: enhancedMappedData.licence_number || '', // MOROCCAN LICENSE FIX: Correctly mapped
          customer_id_number: enhancedMappedData.id_number || '', // MOROCCAN LICENSE FIX: Cleared for driving licenses
          customer_place_of_birth: enhancedMappedData.place_of_birth || '',
          customer_issue_date: enhancedMappedData.licence_issue_date || enhancedMappedData.issue_date || ''
        };

        console.log('üéØ FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Mapped extractedData for form:', JSON.stringify(extractedData, null, 2));
        
        // Prepare customer data with scan result using enhanced mapping
        const customerDataWithScan = {
          ...enhancedMappedData, // Use enhanced mapped data instead of raw OCR data
          id_scan_url: publicUrl, // CRITICAL: Include image URL
          scanUrl: publicUrl // Alternative field name
        };

        // Create scan result object for saveCustomer function
        const scanResult = {
          file_public_url: publicUrl,
          file_path: filePath,
          success: true
        };

        console.log('üíæ FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Saving customer with enhanced OCR data and image URL...');
        customerSaveResult = await this.saveCustomer(customerDataWithScan, scanResult);

        if (customerSaveResult.success) {
          shouldPopulateForm = true;
          responseMessage = `‚úÖ ID scan processed successfully! Customer data extracted and saved with image URL. Form populated with ${Object.keys(extractedData).filter(key => extractedData[key]).length} fields.`;
          console.log('‚úÖ FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Customer saved successfully with enhanced OCR data and image URL');
        } else {
          shouldPopulateForm = false;
          responseMessage = `‚ùå ID scan failed: ${customerSaveResult.error}`;
          console.error('‚ùå FORM AUTO-POPULATION: Customer save failed:', customerSaveResult.error);
        }
      } else {
        // OCR failed, but still save the image URL to customer record if possible
        console.log('‚ö†Ô∏è FORM AUTO-POPULATION: OCR failed, attempting to save image URL only...');
        
        const basicCustomerData = {
          id_scan_url: publicUrl
        };

        const scanResult = {
          file_public_url: publicUrl,
          file_path: filePath,
          success: true
        };

        // Try to update existing customer with image URL
        try {
          const { data: existingCustomer } = await supabase
            .from('app_4c3a7a6153_customers')
            .select('*')
            .eq('id', customerId)
            .single();

          if (existingCustomer) {
            const { error: updateError } = await supabase
              .from('app_4c3a7a6153_customers')
              .update({ 
                id_scan_url: publicUrl,
                updated_at: new Date().toISOString()
              })
              .eq('id', customerId);

            if (!updateError) {
              console.log('‚úÖ FORM AUTO-POPULATION: Image URL saved to existing customer record');
            }
          }
        } catch (error) {
          console.log('‚ö†Ô∏è FORM AUTO-POPULATION: Could not update customer with image URL:', error.message);
        }

        shouldPopulateForm = false;
        responseMessage = 'Image uploaded but OCR processing failed. Please enter customer details manually.';
      }

      console.log('‚úÖ FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Sequential image upload process completed');
      
      // CRITICAL: Return the correct format with extractedData for form auto-population
      const result = {
        success: true,
        publicUrl: publicUrl,
        filePath: filePath,
        ocrResult: ocrResult,
        customerSaveResult: customerSaveResult,
        shouldPopulateForm: shouldPopulateForm,
        extractedData: extractedData, // CRITICAL: This is what enables form auto-population
        message: responseMessage,
        // Additional fields for compatibility
        scanId: `scan_${timestamp}`,
        scanNumber: 1,
        updateResult: {
          success: true,
          shouldPopulateForm: shouldPopulateForm,
          shouldMarkComplete: true
        }
      };

      console.log('üéØ FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Final result with extractedData:', JSON.stringify(result, null, 2));
      return result;

    } catch (error) {
      console.error('‚ùå FORM AUTO-POPULATION + MOROCCAN LICENSE FIX: Sequential image upload failed:', error);
      return {
        success: false,
        error: error.message,
        shouldPopulateForm: false,
        extractedData: {}, // Empty object for failed cases
        message: 'Failed to process image upload'
      };
    }
  }

  /**
   * Enhanced customer data sanitization
   */
  static sanitizeCustomerData(customerData) {
    const sanitized = { ...customerData };

    console.log('üßπ Sanitizing customer data:', customerData);

    // Handle date fields
    const dateFields = ['date_of_birth', 'customer_dob', 'issue_date', 'customer_issue_date', 'licence_issue_date', 'licence_expiry_date'];
    dateFields.forEach(field => {
      if (field in sanitized) {
        const originalValue = sanitized[field];
        if (!originalValue || (typeof originalValue === 'string' && originalValue.trim() === '')) {
          sanitized[field] = null;
        } else {
          // Try to format date
          try {
            const date = new Date(originalValue);
            if (!isNaN(date.getTime())) {
              sanitized[field] = date.toISOString().split('T')[0]; // YYYY-MM-DD format
            } else {
              sanitized[field] = null;
            }
          } catch (error) {
            sanitized[field] = null;
          }
        }
        console.log(`üìÖ Date field '${field}': '${originalValue}' -> '${sanitized[field]}'`);
      }
    });

    // Handle string fields that should be null when empty
    const stringFields = [
      'email', 'customer_email',
      'nationality', 'customer_nationality',
      'licence_number', 'customer_licence_number',
      'id_number', 'customer_id_number',
      'place_of_birth', 'customer_place_of_birth'
    ];
    
    stringFields.forEach(field => {
      if (field in sanitized && (!sanitized[field] || (typeof sanitized[field] === 'string' && sanitized[field].trim() === ''))) {
        const originalValue = sanitized[field];
        sanitized[field] = null;
        console.log(`üìß String field '${field}': '${originalValue}' -> null`);
      }
    });

    console.log('‚úÖ Customer data sanitization completed:', sanitized);
    return sanitized;
  }

  /**
   * Get customer by ID
   */
  static async getCustomerById(customerId) {
    console.log('üîç Fetching customer by ID:', customerId);
    
    try {
      const { data, error } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('*')
        .eq('id', customerId)
        .single();
      
      if (error) {
        console.error('‚ùå Error fetching customer:', error);
        throw new Error(`Failed to fetch customer: ${error.message}`);
      }
      
      console.log('‚úÖ Fetched customer:', data);
      return data;
      
    } catch (error) {
      console.error('‚ùå Error in getCustomerById:', error);
      throw error;
    }
  }

  /**
   * Get all customers with filtering
   */
  static async getAllCustomers(filters = {}) {
    console.log('üìã Fetching all customers with filters:', filters);
    
    try {
      let query = supabase
        .from('app_4c3a7a6153_customers')
        .select('*')
        .order('created_at', { ascending: false });
      
      // Apply filters
      if (filters.search) {
        query = query.or(`full_name.ilike.%${filters.search}%,phone.ilike.%${filters.search}%,email.ilike.%${filters.search}%`);
      }
      
      if (filters.nationality) {
        query = query.eq('nationality', filters.nationality);
      }
      
      const { data, error } = await query;
      
      if (error) {
        console.error('‚ùå Error fetching customers:', error);
        throw new Error(`Failed to fetch customers: ${error.message}`);
      }
      
      console.log('‚úÖ Fetched customers:', data?.length || 0);
      return data || [];
      
    } catch (error) {
      console.error('‚ùå Error in getAllCustomers:', error);
      throw error;
    }
  }

  /**
   * Delete customer
   */
  static async deleteCustomer(customerId) {
    console.log('üóëÔ∏è Deleting customer:', customerId);
    
    try {
      const { error } = await supabase
        .from('app_4c3a7a6153_customers')
        .delete()
        .eq('id', customerId);
      
      if (error) {
        console.error('‚ùå Error deleting customer:', error);
        throw new Error(`Failed to delete customer: ${error.message}`);
      }
      
      console.log('‚úÖ Customer deleted successfully');
      return { success: true, message: 'Customer deleted successfully' };
      
    } catch (error) {
      console.error('‚ùå Error in deleteCustomer:', error);
      throw error;
    }
  }

  /**
   * Search customers by various criteria
   */
  static async searchCustomers(searchTerm) {
    console.log('üîç Searching customers with term:', searchTerm);
    
    try {
      const { data, error } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('*')
        .or(`full_name.ilike.%${searchTerm}%,phone.ilike.%${searchTerm}%,email.ilike.%${searchTerm}%,licence_number.ilike.%${searchTerm}%,id_number.ilike.%${searchTerm}%`)
        .order('created_at', { ascending: false });
      
      if (error) {
        console.error('‚ùå Error searching customers:', error);
        throw new Error(`Failed to search customers: ${error.message}`);
      }
      
      console.log('‚úÖ Found customers:', data?.length || 0);
      return data || [];
      
    } catch (error) {
      console.error('‚ùå Error in searchCustomers:', error);
      throw error;
    }
  }

  /**
   * Get customer by licence number
   */
  static async getCustomerByLicenceNumber(licenceNumber) {
    console.log('üîç Fetching customer by licence number:', licenceNumber);
    
    try {
      const { data, error } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('*')
        .eq('licence_number', licenceNumber)
        .single();
      
      if (error) {
        if (error.code === 'PGRST116') {
          // No rows returned
          return null;
        }
        console.error('‚ùå Error fetching customer by licence:', error);
        throw new Error(`Failed to fetch customer by licence: ${error.message}`);
      }
      
      console.log('‚úÖ Found customer by licence:', data);
      return data;
      
    } catch (error) {
      console.error('‚ùå Error in getCustomerByLicenceNumber:', error);
      throw error;
    }
  }

  /**
   * Get customer by ID number
   */
  static async getCustomerByIdNumber(idNumber) {
    console.log('üîç Fetching customer by ID number:', idNumber);
    
    try {
      const { data, error } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('*')
        .eq('id_number', idNumber)
        .single();
      
      if (error) {
        if (error.code === 'PGRST116') {
          // No rows returned
          return null;
        }
        console.error('‚ùå Error fetching customer by ID number:', error);
        throw new Error(`Failed to fetch customer by ID number: ${error.message}`);
      }
      
      console.log('‚úÖ Found customer by ID number:', data);
      return data;
      
    } catch (error) {
      console.error('‚ùå Error in getCustomerByIdNumber:', error);
      throw error;
    }
  }

  /**
   * CRITICAL DEBUG: Get specific customer for debugging
   */
  static async debugCustomerRecord(customerId) {
    console.log('üîç DEBUG: Fetching customer record for debugging:', customerId);
    
    try {
      const { data, error } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('*')
        .eq('id', customerId)
        .single();
      
      if (error) {
        console.error('‚ùå DEBUG: Error fetching customer:', error);
        return { success: false, error: error.message };
      }
      
      console.log('üîç DEBUG: Customer record details:');
      console.log('  - ID:', data.id);
      console.log('  - Full Name:', data.full_name);
      console.log('  - Phone:', data.phone);
      console.log('  - Email:', data.email);
      console.log('  - ID Number:', data.id_number);
      console.log('  - License Number:', data.licence_number);
      console.log('  - ID Scan URL:', data.id_scan_url);
      console.log('  - Created:', data.created_at);
      console.log('  - Updated:', data.updated_at);
      console.log('üîç DEBUG: Complete record:', JSON.stringify(data, null, 2));
      
      return { success: true, data };
      
    } catch (error) {
      console.error('‚ùå DEBUG: Error in debugCustomerRecord:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Run diagnostics on customer service
   */
  static async runDiagnostics() {
    console.log('üîß Running customer service diagnostics...');
    
    const diagnostics = {
      timestamp: new Date().toISOString(),
      tests: {}
    };
    
    try {
      // Test 1: Database Connection
      console.log('üîß Testing customer database connection...');
      const { data: connectionTest, error: connectionError } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('count', { count: 'exact', head: true });
      
      if (connectionError) {
        diagnostics.tests.databaseConnection = {
          status: 'FAIL',
          error: connectionError.message
        };
      } else {
        diagnostics.tests.databaseConnection = {
          status: 'PASS',
          message: 'Customer database connection successful'
        };
      }
      
      // Test 2: Table Access
      console.log('üîß Testing customer table access...');
      const { data: tableTest, error: tableError } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('id')
        .limit(1);
      
      if (tableError) {
        diagnostics.tests.tableAccess = {
          status: 'FAIL',
          error: tableError.message
        };
      } else {
        diagnostics.tests.tableAccess = {
          status: 'PASS',
          message: 'Customer table access successful'
        };
      }
      
      // Test 3: Count customers
      console.log('üîß Counting customers...');
      const { count, error: countError } = await supabase
        .from('app_4c3a7a6153_customers')
        .select('*', { count: 'exact', head: true });
      
      if (countError) {
        diagnostics.tests.customerCount = {
          status: 'FAIL',
          error: countError.message
        };
      } else {
        diagnostics.tests.customerCount = {
          status: 'PASS',
          message: `Found ${count} customers in database`
        };
      }

      // Test 4: FINAL FIX - Test id_scan_url field presence
      console.log('üîß Testing id_scan_url field presence...');
      try {
        const { data: sampleCustomer, error: sampleError } = await supabase
          .from('app_4c3a7a6153_customers')
          .select('id, id_scan_url, phone')
          .limit(1)
          .single();
        
        if (sampleError && sampleError.code !== 'PGRST116') {
          diagnostics.tests.idScanUrlField = {
            status: 'FAIL',
            error: sampleError.message
          };
        } else {
          diagnostics.tests.idScanUrlField = {
            status: 'PASS',
            message: 'id_scan_url and phone fields accessible in customer table',
            sampleData: sampleCustomer
          };
        }
      } catch (error) {
        diagnostics.tests.idScanUrlField = {
          status: 'FAIL',
          error: error.message
        };
      }

      // Test 5: PHONE MAPPING DEBUG - Test specific customer
      console.log('üîß Testing specific customer cust_1763257670216_y0at1di1c...');
      try {
        const debugResult = await this.debugCustomerRecord('cust_1763257670216_y0at1di1c');
        
        diagnostics.tests.specificCustomerDebug = {
          status: debugResult.success ? 'PASS' : 'FAIL',
          message: debugResult.success ? 'Customer record retrieved successfully' : debugResult.error,
          customerData: debugResult.data || null
        };
      } catch (error) {
        diagnostics.tests.specificCustomerDebug = {
          status: 'FAIL',
          error: error.message
        };
      }

      // Test 6: FORM AUTO-POPULATION - Test processSequentialImageUpload function availability
      console.log('üîß Testing processSequentialImageUpload function availability...');
      try {
        const functionExists = typeof this.processSequentialImageUpload === 'function';
        
        diagnostics.tests.processSequentialImageUploadFunction = {
          status: functionExists ? 'PASS' : 'FAIL',
          message: functionExists ? 'processSequentialImageUpload function is available with form auto-population support' : 'processSequentialImageUpload function is missing',
          functionExists: functionExists
        };
      } catch (error) {
        diagnostics.tests.processSequentialImageUploadFunction = {
          status: 'FAIL',
          error: error.message
        };
      }

      // Test 7: MOROCCAN LICENSE FIX - Test enhancedOcrDataMapping function availability
      console.log('üîß Testing enhancedOcrDataMapping function availability...');
      try {
        const functionExists = typeof this.enhancedOcrDataMapping === 'function';
        
        diagnostics.tests.enhancedOcrDataMappingFunction = {
          status: functionExists ? 'PASS' : 'FAIL',
          message: functionExists ? 'enhancedOcrDataMapping function is available with Moroccan driving license support' : 'enhancedOcrDataMapping function is missing',
          functionExists: functionExists
        };
      } catch (error) {
        diagnostics.tests.enhancedOcrDataMappingFunction = {
          status: 'FAIL',
          error: error.message
        };
      }
      
      console.log('‚úÖ Customer service diagnostics completed:', diagnostics);
      return diagnostics;
      
    } catch (error) {
      console.error('‚ùå Customer service diagnostics failed:', error);
      diagnostics.tests.generalError = {
        status: 'FAIL',
        error: error.message
      };
      return diagnostics;
    }
  }
}

export default EnhancedUnifiedCustomerService;
